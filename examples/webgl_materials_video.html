<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - video</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="overlay">
			<button id="startButton">Play</button>
		</div>
		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl video demo<br/>
			playing <a href="http://durian.blender.org/" target="_blank" rel="noopener">sintel</a> trailer
		</div>

		<video id="video" loop crossOrigin="anonymous" playsinline style="display:none">
			<source src="textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
			<source src="https://foveate3dn.nyc3.cdn.digitaloceanspaces.com/labs/researchstream.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { BloomPass } from 'three/addons/postprocessing/BloomPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';


			let container;

			let camera, scene, renderer;

			let video, texture, material, mesh;

			let composer;

			let mouseX = 0;
			let mouseY = 0;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

			//let cube_count;

			// const meshes = [],
			// 	materials = [],

			// 	xgrid = 20,
			// 	ygrid = 10;

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', function () {

				init();
				animate();

			} );

			function init() {

				const overlay = document.getElementById( 'overlay' );
				overlay.remove();

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( - 10, 2, 10 );

				//camera.position.z = 500;

				scene = new THREE.Scene();

				const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 0.5, 1, 1 ).normalize();
				scene.add( light );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				container.appendChild( renderer.domElement );



				
				video = document.getElementById( 'video' );
				video.play();
				video.addEventListener( 'play', function () {

					this.currentTime = 3;

				} );

				texture = new THREE.VideoTexture( video );
				texture.colorSpace = THREE.SRGBColorSpace;
				texture.flipY = false;

				

				// let i, j, ox, oy, geometry;

				// const ux = 1 / xgrid;
				// const uy = 1 / ygrid;

				// const xsize = 480 / xgrid;
				// const ysize = 204 / ygrid;

				// const parameters = { color: 0xffffff, map: texture };

				// cube_count = 0;

				


				// for ( i = 0; i < xgrid; i ++ ) {

				// 	for ( j = 0; j < ygrid; j ++ ) {

				// 		ox = i;
				// 		oy = j;

				// 		geometry = new THREE.BoxGeometry( xsize, ysize, xsize );

				// 		change_uvs( geometry, ux, uy, ox, oy );

				// 		materials[ cube_count ] = new THREE.MeshLambertMaterial( parameters );

				// 		material = materials[ cube_count ];

				// 		material.hue = i / xgrid;
				// 		material.saturation = 1 - j / ygrid;

				// 		material.color.setHSL( material.hue, material.saturation, 0.5 );

				// 		mesh = new THREE.Mesh( geometry, material );

				// 		mesh.position.x = ( i - xgrid / 2 ) * xsize;
				// 		mesh.position.y = ( j - ygrid / 2 ) * ysize;
				// 		mesh.position.z = 0;

				// 		mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;

				// 		scene.add( mesh );

				// 		mesh.dx = 0.001 * ( 0.5 - Math.random() );
				// 		mesh.dy = 0.001 * ( 0.5 - Math.random() );

				// 		meshes[ cube_count ] = mesh;

				// 		cube_count += 1;

				// 	}

				// }
				new RGBELoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( envtexture ) {

						envtexture.mapping = THREE.EquirectangularReflectionMapping;

						scene.background = envtexture;
						scene.environment = envtexture;

						render();
						
						// model


						const loader = new GLTFLoader().setPath( 'https://foveate3dn.nyc3.cdn.digitaloceanspaces.com/labs/researchstream_separate.glb' );
						loader.load( 'https://foveate3dn.nyc3.cdn.digitaloceanspaces.com/labs/researchstream_separate.glb', async function ( gltf ) {
							const model = gltf.scene;

							const mesh = model.children.find(child => child.isMesh);
							
							const material = new THREE.MeshStandardMaterial({ 

							});

							mesh.material.map = texture;
							mesh.material.emissiveMap = texture;
							//mesh.material.emissive = 0xffffff,
							mesh.material.envMap = scene.environment, 
							mesh.material.emissiveIntensity = 5, 
							mesh.material.metalness = 0, 
							mesh.material.roughness = 1,

							mesh.material.needsUpdate = true;

							// wait until the model can be added to the scene without blocking due to shader compilation

							await renderer.compileAsync( model, camera, scene );

							scene.add( model );

							render();
			
						} );

					} );
				

				renderer.autoClear = false;

				document.addEventListener( 'mousemove', onDocumentMouseMove );

				// postprocessing

				const renderPass = new RenderPass( scene, camera );
				const bloomPass = new BloomPass( 1 );
				const outputPass = new OutputPass();

				composer = new EffectComposer( renderer );

				composer.addPass( renderPass );
				composer.addPass( bloomPass );
				composer.addPass( outputPass );

				//
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 2;
				controls.maxDistance = 100;
				controls.target.set( 0, 0, - 0.2 );
				controls.update();


				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				composer.setSize( window.innerWidth, window.innerHeight );

			}

			function change_uvs( geometry, unitx, unity, offsetx, offsety ) {

				const uvs = geometry.attributes.uv.array;

				for ( let i = 0; i < uvs.length; i += 2 ) {

					uvs[ i ] = ( uvs[ i ] + offsetx ) * unitx;
					uvs[ i + 1 ] = ( uvs[ i + 1 ] + offsety ) * unity;

				}

			}


			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY ) * 0.3;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			let h, counter = 1;

			function render() {

				//const time = Date.now() * 0.00005;

				// camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				// camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

				// camera.lookAt( scene.position );

				// for ( let i = 0; i < cube_count; i ++ ) {

				// 	material = materials[ i ];

				// 	h = ( 360 * ( material.hue + time ) % 360 ) / 360;
				// 	material.color.setHSL( h, material.saturation, 0.5 );

				// }

				// if ( counter % 1000 > 200 ) {

				// 	for ( let i = 0; i < cube_count; i ++ ) {

				// 		mesh = meshes[ i ];

				// 		mesh.rotation.x += 10 * mesh.dx;
				// 		mesh.rotation.y += 10 * mesh.dy;

				// 		mesh.position.x -= 150 * mesh.dx;
				// 		mesh.position.y += 150 * mesh.dy;
				// 		mesh.position.z += 300 * mesh.dx;

				// 	}

				// }

				// if ( counter % 1000 === 0 ) {

				// 	for ( let i = 0; i < cube_count; i ++ ) {

				// 		mesh = meshes[ i ];

				// 		mesh.dx *= - 1;
				// 		mesh.dy *= - 1;

				// 	}

				// }

				// counter ++;

				renderer.clear();
				composer.render();

			}


		</script>

	</body>
</html>
