<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - video</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="overlay">
			<button id="startButton">Play</button>
		</div>
		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl video demo<br/>
			playing <a href="http://durian.blender.org/" target="_blank" rel="noopener">sintel</a> trailer
		</div>

		<video id="video" loop crossOrigin="anonymous" playsinline style="display:none">
			<source src="textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
			<source src="https://foveate3dn.nyc3.cdn.digitaloceanspaces.com/labs/cotai-gradient-test.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
			<source src="https://foveate3dn.nyc3.cdn.digitaloceanspaces.com/labs/cotai-gradient-test.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>

		</video>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { BloomPass } from 'three/addons/postprocessing/BloomPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';


			let container;

			let camera, scene, renderer;

			let video, texture, material, mesh;

			let composer;

			let mouseX = 0;
			let mouseY = 0;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

			//let cube_count;

			// const meshes = [],
			// 	materials = [],

			// 	xgrid = 20,
			// 	ygrid = 10;

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', function () {

				init();
				animate();

			} );

			function init() {

				const overlay = document.getElementById( 'overlay' );
				overlay.remove();

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, .1, 100000 );
				camera.position.set( - 10, 2, 10 );

				//camera.position.z = 500;

				scene = new THREE.Scene();

				const light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 0.5, 10, 1 ).normalize();
				scene.add( light );


				const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
				scene.add(ambientLight);


				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = .9;
				container.appendChild( renderer.domElement );



				
				video = document.getElementById( 'video' );
				video.play();
				video.addEventListener( 'play', function () {

					this.currentTime = 3;

				} );

				texture = new THREE.VideoTexture( video );
				texture.colorSpace = THREE.SRGBColorSpace;
				texture.flipY = false;
				texture.minFilter = THREE.LinearFilter;
				

				
				new RGBELoader()
					.setPath( )
					.load( 'https://foveate3dn.nyc3.cdn.digitaloceanspaces.com/labs/studio_small_08_1k.hdr', function ( envtexture ) {

						envtexture.mapping = THREE.EquirectangularReflectionMapping;
						scene.environmentRotation = 0,3.14,0;
						scene.backgroundRotation = 0,3.14,0;
						scene.background = 0x101010;
						scene.environment = envtexture;

						render();
						


						// Load the alpha map texture
						const textureLoader = new THREE.TextureLoader();
						const alphaMap = textureLoader.load('https://foveate3dn.nyc3.cdn.digitaloceanspaces.com/labs/alpah-mask.jpg')
						alphaMap.flipY = false;

						// model
	



						const loader = new GLTFLoader();


						loader.load( 'https://foveate3dn.nyc3.cdn.digitaloceanspaces.com/labs/mgm-cotai_venue.glb', ( gltf2 )  => {
								scene.add( gltf2.scene);



						loader.load( 'https://foveate3dn.nyc3.cdn.digitaloceanspaces.com/labs/cotai_flat.glb',  ( gltf )  => {
					

						

							//scene.add( model2 );
							const model = gltf.scene;

							const mesh = model.children.find(child => child.isMesh);
							console.log(mesh)

							const material = new THREE.MeshStandardMaterial({});
							mesh.material.map = texture;
							mesh.material.emissiveMap = texture;
							mesh.material.emissive = new THREE.Color(0xffffff),
							mesh.material.envMap = scene.environment; 
							mesh.material.envMapRotation = 0,3.14,0;
							mesh.material.emissiveIntensity = 1; 
							mesh.material.metalness = 0; 
							mesh.material.roughness = 1;
							mesh.material.transparent = true;
							mesh.material.dithering = true;
							mesh.material.toneMapping = true;
							mesh.material.premultipliedAlpha = true;
							mesh.material.needsUpdate = true;
							mesh.material.side = THREE.DoubleSide,
							mesh.material.alphaMap = alphaMap,

							// wait until the model can be added to the scene without blocking due to shader compilation

							//await renderer.compileAsync( model, camera, scene );

							scene.add( model);

							render();
						
								},) 
						
						} );

					} );
					
				

				renderer.autoClear = false;

				document.addEventListener( 'mousemove', onDocumentMouseMove );

				// postprocessing

				const renderPass = new RenderPass( scene, camera );
				const bloomPass = new BloomPass( 0.25 );
				const outputPass = new OutputPass();

				composer = new EffectComposer( renderer );

				composer.addPass( renderPass );
				composer.addPass( bloomPass );
				composer.addPass( outputPass );

				//
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 2;
				controls.maxDistance = 500;
				controls.target.set( 0, 0, - 0.2 );
				controls.update();


				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				composer.setSize( window.innerWidth, window.innerHeight );

			}

			function change_uvs( geometry, unitx, unity, offsetx, offsety ) {

				const uvs = geometry.attributes.uv.array;

				for ( let i = 0; i < uvs.length; i += 2 ) {

					uvs[ i ] = ( uvs[ i ] + offsetx ) * unitx;
					uvs[ i + 1 ] = ( uvs[ i + 1 ] + offsety ) * unity;

				}

			}


			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY ) * 0.3;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			let h, counter = 1;

			function render() {

				//const time = Date.now() * 0.00005;

				// camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				// camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

				// camera.lookAt( scene.position );

				// for ( let i = 0; i < cube_count; i ++ ) {

				// 	material = materials[ i ];

				// 	h = ( 360 * ( material.hue + time ) % 360 ) / 360;
				// 	material.color.setHSL( h, material.saturation, 0.5 );

				// }

				// if ( counter % 1000 > 200 ) {

				// 	for ( let i = 0; i < cube_count; i ++ ) {

				// 		mesh = meshes[ i ];

				// 		mesh.rotation.x += 10 * mesh.dx;
				// 		mesh.rotation.y += 10 * mesh.dy;

				// 		mesh.position.x -= 150 * mesh.dx;
				// 		mesh.position.y += 150 * mesh.dy;
				// 		mesh.position.z += 300 * mesh.dx;

				// 	}

				// }

				// if ( counter % 1000 === 0 ) {

				// 	for ( let i = 0; i < cube_count; i ++ ) {

				// 		mesh = meshes[ i ];

				// 		mesh.dx *= - 1;
				// 		mesh.dy *= - 1;

				// 	}

				// }

				// counter ++;

				renderer.clear();
				composer.render();

			}


		</script>

	</body>
</html>
